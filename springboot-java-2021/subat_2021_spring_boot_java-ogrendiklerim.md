# Day-1
Reserved Words
Also known as keywords, are particular words which are predefined in Java and cannot be used as variable or object name. 
Some of the important keywords are :

Keywords	Usage
abstract:	used to declare an abstract class.
catch	:   used to catch exceptions generated by try statements.
class	:	used to declare a class.
enum	:	defines a set of constants
extends	:	indicates that class is inherited
final	:	indicates the value cannot be changed
finally	:	used to execute code after the try-catch structure.
implements: used to implement an interface.
new	:		used to create new objects.
static	:	used to indicate that a variable or a method is a class method.
super	:	used to refer to the parent class.
this	:	used to refer to the current object in a method or constructor.
throw	:	used to explicitly throw an exception.
throws	:	used to declare an exception.
try		:	block of code to handle an exception

# Day-2
Typecasting
It is a method of converting a variable of one data type to another data type so that functions can process these variables correctly.

Java defines two types of typecasting:

Implicit Type Casting (Widening): Storing a variable of a smaller data type to a larger data type.
Explicit Typecasting (Narrowing): Storing variable of a larger data type to a smaller data type.
# Day-3
Primitive Data Types in Java
Data Type	Default Value	Size (in bytes) 1 byte = 8 bits
boolean	FALSE	1 bit
char		“ “ (space)		2 byte
byte		0				1 byte
short		0				2 byte
int			0				4 byte
long		0				8 byte
float		0.0f 			4 byte
double		0.0d 			8 byte

Non-Primitive Data Types
String
Array
Class
Interface

# Day-4
Escape Sequences
If you need to use a backslash or a double quotation mark in a string, you need to
prefix it with a backslash. This is called escaping.
Common escape sequences:
• \\
• \”
• \n (new line)
• \t (tab) 

# Day-5
Multi-dimensional Arrays
// Creating a 2x3 array (two rows, three columns)
```java
int[2][3] matrix = new int[2][3];
matrix[0][0] = 10;
// Shortcut
int[2][3] matrix = {
 { 1, 2, 3 },
 { 4, 5, 6 }
 };
```

# Day-6
Formatting Numbers
```java
NumberFormat currency = NumberFormat.getCurrencyInstance();
String result = currency.format(“123456”); // $123,456

NumberFormat percent = NumberFormat.getPercentInstance();
String result = percent(“0.04”); // 4%
```

# Day-7
Reading Input

```java
Scanner scanner = new Scanner(system.in);
double number = scanner.nextDouble();
byte number = scanner.nextByte();
String name = scanner.next();
String line = scanner.nextLine();
```

# Day-8

javada çok fazla dönen bir foreach için debug koymak için bir sayaç konup bu değere ulaşma noktasına debug konabilir.
örnek uygulama1
```java
int index = 0;
for(Element song : question) {
    System.out.println("Current index is: " + (index++));
}
```
örnek uygulama2
```java
for (Index<String> each: With.index(stringArray)) {
    each.value;
    each.index;
    ...
}
```


# Day-9
The Ternary Operator
```java
String className = (income > 100_000) ? “First” : “Economy”;
```
This is a shorthand to write the following code:
```java
String className;
if (income > 100_000)
 className = “First”;
else
 className = “Economy”;
```

# Day-10
```java
@SpringBootApplicaiton
```
First one of the most basic, super helpful annotations, our all time favorite @SpringBootApplication. There's nothing magical about it. It's syntactic sugar for combining other annotations that we'll look at in just a moment. @SpringBootApplication is @Configuration, @EnableAutoConfiguration and @ComponentScan annotations combined, configured with their default attributes.

[https://www.jrebel.com/blog/spring-annotations-cheat-sheet]
# Day-11
```java
@Configuration and @ComponentScan
```
The @Configuration and @ComponentScan annotations that we described above make Spring create and configure the beans and components of your application. It's a great way to decouple the actual business logic code from wiring the app together.
[https://www.jrebel.com/blog/spring-annotations-cheat-sheet]

# Day-12
```java
@EnableAutoConfiguration
```
Now the @EnableAutoConfiguration annotation is even better. It makes Spring guess the configuration based on the JAR files available on the classpath. It can figure out what libraries you use and preconfigure their components without you lifting a finger. It is how all the spring-boot-starter libraries work. Meaning it's a major lifesaver both when you're just starting to work with a library as well as when you know and trust the default config to be reasonable.
[https://www.jrebel.com/blog/spring-annotations-cheat-sheet]

# Day-13
```java
@Controller
```
@Controller marks the class as a web controller, capable of handling the HTTP requests. Spring will look at the methods of the class marked with the @Controller annotation and establish the routing table to know which methods serve which endpoints.
[https://www.jrebel.com/blog/spring-annotations-cheat-sheet]

# Day-14
```java
@ResponseBody
```
The @ResponseBody is a utility annotation that makes Spring bind a method's return value to the HTTP response body. When building a JSON endpoint, this is an amazing way to magically convert your objects into JSON for easier consumption.
[https://www.jrebel.com/blog/spring-annotations-cheat-sheet]

# Day-15
```java
@RestController
```
Then there's the @RestController annotation -- a convenience syntax for @Controller and @ResponseBody together. This means that all the action methods in the marked class will return the JSON response.
[https://www.jrebel.com/blog/spring-annotations-cheat-sheet]

# Day-16
```java
@RequestMapping(method = RequestMethod.GET, value = "/path")
```
The @RequestMapping(method = RequestMethod.GET, value = "/path") annotation specifies a method in the controller that should be responsible for serving the HTTP request to the given path. Spring will work the implementation details of how it's done. You simply specify the path value on the annotation and Spring will route the requests into the correct action methods.
[https://www.jrebel.com/blog/spring-annotations-cheat-sheet]

# Day-17
```java
@RequestParam(value="name", defaultValue="World")
```
Naturally, the methods handling the requests might take parameters. To help you with binding the HTTP parameters into the action method arguments, you can use the @RequestParam(value="name", defaultValue="World") annotation. Spring will parse the request parameters and put the appropriate ones into your method arguments.

[https://www.jrebel.com/blog/spring-annotations-cheat-sheet]

# Day-18
```java
@PathVariable("placeholderName")
```
Another common way to provide information to the backend is to encode it in the URL. Then you can use the @PathVariable("placeholderName") annotation to bring the values from the URL to the method arguments.

[https://www.jrebel.com/blog/spring-annotations-cheat-sheet]